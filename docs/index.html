<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RMQ - RabbitMQ C++ Library: rmqcpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RMQ - RabbitMQ C++ Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">rmqcpp </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_docs_doxygen"></a> <code>rmqcpp</code> is a RabbitMQ client library written in C++03.</p>
<h1>RabbitContext</h1>
<p ><code>rmqa::RabbitContext</code> provides an API for connecting to RabbitMQ virtual hosts (vhosts). The <code>RabbitContext</code> object stores:</p>
<ul>
<li>Threadpool for callbacks;</li>
<li>Metric publisher; and</li>
<li>Error callback.</li>
</ul>
<p ><code>RabbitContext</code> contains default implementations of them as detailed below. Users can replace these components with a <code>rmqa::RabbitContextOptions</code> object.</p>
<p >Threadpool is used for asynchronous callbacks to the user code (e.g., received messages, publisher confirms, error callbacks). A <code>bdlmt::ThreadPool</code> is created by default.</p>
<p >Metric publisher is used to publish internal library metrics. Users can provide their own implementation for publishing these metrics by implementing the <code>rmqp::MetricPublisher</code> interface. Alternatively, publishing can be disabled by passing an instance of <code>rmqa::NoOpMetricPublisher</code>.</p>
<p >Error callback is called when a connection or channel is closed by the RabbitMQ broker.</p>
<p >Important &ndash; <code>RabbitContext</code> object must outlive other library objects (<code>VHost</code>, <code>Producer</code>, <code>Consumer</code>).</p>
<div class="fragment"><div class="line"><span class="comment">// Create a RabbitContext object. This object must outlive all other library objects.</span></div>
<div class="line">rmqa::RabbitContext context;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Only if necessary, create an options object to provide custom components for the library</span></div>
<div class="line">rmqa::RabbitContextOptions options;</div>
<div class="line">options.setThreadpool(<span class="comment">/* threadpool */</span>);</div>
<div class="line">options.setMetricPublisher(<span class="comment">/* metric publisher */</span>);</div>
<div class="line">options.setErrorCallback(<span class="comment">/* error callback */</span>);</div>
<div class="line"> </div>
<div class="line">rmqa::RabbitContext contextWithOptions(options);</div>
</div><!-- fragment --><h1>VHost</h1>
<p ><code>rmqa::VHost</code> provides an API for creating producer and consumer objects on the selected RabbitMQ vhost. A <code>VHost</code> object can be created from <code>rmqa::RabbitContext</code>.</p>
<div class="fragment"><div class="line">rmqt::VHostInfo vhostInfo(</div>
<div class="line">    bsl::make_shared&lt;rmqt::SimpleEndpoint&gt;(<span class="stringliteral">&quot;rabbit&quot;</span>, <span class="stringliteral">&quot;vhost-name&quot;</span>),</div>
<div class="line">    bsl::make_shared&lt;rmqt::PlainCredentials&gt;(guest, guest));</div>
<div class="line">    </div>
<div class="line">bsl::shared_ptr&lt;rmqa::VHost&gt; vhost = context.createVHostConnection(</div>
<div class="line">    <span class="stringliteral">&quot;my-producer-connection&quot;</span>, vhostInfo); <span class="comment">// returns immediately</span></div>
</div><!-- fragment --><p >Creating a <code>rmqa::VHost</code> instance <b>does not</b> immediately create a connection with the RabbitMQ broker. These connections are created lazily when calling <code>rmqa::VHost::createProducer</code> and <code>rmqa::VHost::createConsumer</code>.</p>
<h1>Topology</h1>
<p >For a more elaborate documentation of the topology, see <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">AMQP 0-9-1 Model Explained</a>.</p>
<p >AMQP topology consists of:</p><ul>
<li>exchanges;</li>
<li>queues; and</li>
<li>bindings.</li>
</ul>
<p >Each publisher sends messages to a particular exchange. Each consumer consumes messages from a particular queue. Exchanges and queues are connected using bindings.</p>
<div class="fragment"><div class="line"><span class="comment">// Create topology</span></div>
<div class="line">rmqa::Topology topology;</div>
<div class="line">rmqt::QueueHandle q1    = topology.addQueue(<span class="stringliteral">&quot;queue-name&quot;</span>);</div>
<div class="line">rmqt::ExchangeHandle e1 = topology.addExchange(<span class="stringliteral">&quot;exch-name&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bind e1 and q1 using binding key &#39;key&#39;</span></div>
<div class="line">topology.bind(e1, q1, <span class="stringliteral">&quot;key1&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// To create an auto-generated queue</span></div>
<div class="line">rmqt::QueueHandle q2 = topology.addQueue();</div>
<div class="line">topology.bind(e1, q2, <span class="stringliteral">&quot;key2&quot;</span>);</div>
</div><!-- fragment --><h1>Producing messages</h1>
<p >Messages can be sent to a RabbitMQ broker using a <code>rmqa::Producer</code> object. To create one, it is necessary to provide:</p><ul>
<li>a topology object;</li>
<li>the exchange to which the publisher will publish; and</li>
<li>the maximum number of unconfirmed messages before <code>send</code> blocks.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// How many messages can be awaiting confirmation before `send` blocks</span></div>
<div class="line"><span class="keyword">const</span> uint16_t maxOutstandingConfirms = 10;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a producer object</span></div>
<div class="line">rmqt::Result&lt;rmqa::Producer&gt; producerResult =</div>
<div class="line">    vhost-&gt;createProducer(topology, e1, maxOutstandingConfirms);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!producerResult) {</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">    bsl::cout &lt;&lt; <span class="stringliteral">&quot;Error creating connection: &quot;</span> &lt;&lt; producerResult.error();</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">bsl::shared_ptr&lt;rmqa::Producer&gt; producer = producerResult.value();</div>
</div><!-- fragment --><p >When sending a message, provide a callback function to be invoked when the publisher confirm is received from the broker.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> receiveConfirmation(<span class="keyword">const</span> rmqt::Message&amp; message,</div>
<div class="line">                         <span class="keyword">const</span> bsl::string&amp; routingKey,</div>
<div class="line">                         <span class="keyword">const</span> rmqt::ConfirmResponse&amp; response)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (response.status() == rmqt::ConfirmResponse::ACK) {</div>
<div class="line">        <span class="comment">// Message is now guaranteed to be safe with the broker</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// REJECT / RETURN indicate problem with the send request (bad routing</span></div>
<div class="line">        <span class="comment">// key?)</span></div>
<div class="line">        <span class="comment">// NB: users must handle the send failure to avoid dropping the message!</span></div>
<div class="line">        BALL_LOG_WARN &lt;&lt; <span class="stringliteral">&quot;Sending message failed: &quot;</span> &lt;&lt; response;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >To send a message, construct a <code>rmqt::Message</code> object. Each message needs its own object even when intentionally sending the same message multiple times &ndash; this is because the message ID must be unique.</p>
<div class="fragment"><div class="line"><span class="comment">// Work in progress -- the interface for constructing message payloads is still subject to change</span></div>
<div class="line">bsl::string messageText    = <span class="stringliteral">&quot;Hello RabbitMQ!&quot;</span>;</div>
<div class="line">bsl::vector&lt;uint8_t&gt; &gt; payload(messageText.cbegin(), messageText.cend());</div>
<div class="line">rmqt::Message message(bsl::make_shared&lt;bsl::vector&lt;uint8_t&gt; &gt;(payload));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Method `send` returns immediately unless there are `maxOutstandingConfirms` unacknowledged</span></div>
<div class="line"><span class="comment">// messages already, in which case it waits until at least one confirm comes back.</span></div>
<div class="line"><span class="comment">// User must wait until the confirm callback is executed before considering</span></div>
<div class="line"><span class="comment">// the send to be committed.</span></div>
<div class="line"><span class="keyword">const</span> rmqp::Producer::SendStatus sendResult =</div>
<div class="line">    producer-&gt;send(message, <span class="stringliteral">&quot;key&quot;</span>, &amp;receiveConfirmation);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (sendResult != rmqp::Producer::SENDING) {</div>
<div class="line">    <span class="comment">// handle errors</span></div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Blocks until `timeout` expires or all confirmations have been received</span></div>
<div class="line"><span class="comment">// Note this could block forever if a separate thread continues publishing</span></div>
<div class="line"><span class="keywordflow">if</span> (!producer-&gt;waitForConfirms(<span class="comment">/* timeout */</span>)) {</div>
<div class="line">    <span class="comment">// Timeout expired</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >When shutting down the producer, it is necessary to wait until it receives all outstanding publisher confirms to avoid losing the unconfirmed messages.</p>
<div class="fragment"><div class="line"><span class="comment">// Blocks until `timeout` expires or all confirmations have been received</span></div>
<div class="line"><span class="comment">// Note this could block forever if a separate thread continues publishing</span></div>
<div class="line"><span class="keywordflow">if</span> (!producer-&gt;waitForConfirms(<span class="comment">/* timeout */</span>)) {</div>
<div class="line">    <span class="comment">// Timeout expired</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1>Consumer</h1>
<p >Messages can be consumed from a RabbitMQ broker using a <code>rmqa::Consumer</code>.</p>
<p >Messages are consumed asynchronously. The user-provided consumer callback method will be invoked on the <code>RabbitContext</code> threadpool for every message received.</p>
<p >A <code>Consumer</code> object is created with the following arguments:</p><ul>
<li>the topology that will be declared to the broker;</li>
<li>the queue that the consumer will consume from (must be part of <code>topology</code>);</li>
<li>consumer callback: invoked on every message received (an example is provided below);</li>
<li>consumer label: useful for identifying the consumer in the RabbitMQ Management UI; and</li>
<li>prefetch count: the maximum number of unacknowledged messages before the broker will wait for acks.</li>
</ul>
<div class="fragment"><div class="line">rmqt::Result&lt;rmqa::Consumer&gt; consumerResult = </div>
<div class="line">    vhost-&gt;createConsumer(</div>
<div class="line">        topology,            <span class="comment">// topology</span></div>
<div class="line">        q1,                  <span class="comment">// queue</span></div>
<div class="line">        MessageConsumer(),   <span class="comment">// consumer callback</span></div>
<div class="line">        <span class="stringliteral">&quot;my consumer label&quot;</span>, <span class="comment">// Consumer Label (shows in Management UI)</span></div>
<div class="line">        5                    <span class="comment">// prefetch count</span></div>
<div class="line">    );</div>
</div><!-- fragment --><p >Here is an example of a consumer callback implementation:</p>
<div class="fragment"><div class="line"><span class="comment">// Consumer callback</span></div>
<div class="line"><span class="keyword">class </span>MessageConsumer {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> operator()(rmqp::MessageGuard&amp; guard)</div>
<div class="line">    {</div>
<div class="line">        BALL_LOG_INFO &lt;&lt; <span class="stringliteral">&quot;Received message: &quot;</span> &lt;&lt; guard.message() &lt;&lt; <span class="stringliteral">&quot; Content: &quot;</span></div>
<div class="line">                      &lt;&lt; bsl::string((<span class="keyword">const</span> <span class="keywordtype">char</span>*)guard.message().payload(),</div>
<div class="line">                                     guard.message().payloadSize());</div>
<div class="line">        guard.ack();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p ><b>Important</b> &ndash; messages should be acknowledged only after completely processing them. For example, if the consumer logic sends received messages to some RabbitMQ exchange, the message should be acknowledged only after receiving the publisher confirm of the send operation. A premature call to <code>ack()</code> followed by a failure of the user's consumer logic can result in a dropped message.</p>
<h1>Shutting down</h1>
<div class="fragment"><div class="line"><span class="comment">// Close the producer. The method `waitForConfirms()` will block until all sent messages are confirmed by the broker.</span></div>
<div class="line">producer-&gt;waitForConfirms();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Cancel the consumer.</span></div>
<div class="line">consumer-&gt;cancelAndDrain();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Close the connections to the broker. After calling `rmqa::VHost::close()`, the library will not reconnect to the broker anymore.</span></div>
<div class="line">vhost-&gt;close();</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
